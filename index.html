<!DOCTYPE html>
<html>
<head>
    <title>Tower Defense</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
// Initialization
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const towers = [];
const monsters = [];
let lastTime = 0;
const gridSizeX = 40;
const gridSizeY = 24;
const gridStartPixelX = 0;
const gridStartPixelY = 150;
const gridEndPixelX = ctx.canvas.width;
const gridEndPixelY = ctx.canvas.height;
const gridPixelSizeX = (gridEndPixelX - gridStartPixelX) / gridSizeX;
const gridPixelSizeY = (gridEndPixelY - gridStartPixelY) / gridSizeY;

// Game parameters
const monsterPath = {
    start: {x: gridStartPixelX, y: gridStartPixelY},
    end: {x: gridEndPixelX, y: gridEndPixelY}
};
let spawnInterval = 1000;
let lastSpawn = -spawnInterval;
let lifes = 10;
let monsterKilled = 0;
let money = 100;
let currentSlectedTower = 0;


// convert pixel to grid cell
function pixel2grid(x, y) {
    return {
        gridX: Math.floor((x - gridStartPixelX) / (gridEndPixelX - gridStartPixelX) * gridSizeX),
        gridY: Math.floor((y - gridStartPixelY) / (gridEndPixelY - gridStartPixelY) * gridSizeY),
    };
}

// get upper left corner of grid cell
function grid2pixel(gridX, gridY) {
    return {
        x: gridX * (gridEndPixelX - gridStartPixelX) / gridSizeX + gridStartPixelX,
        y: gridY * (gridEndPixelY - gridStartPixelY) / gridSizeY + gridStartPixelY,
    };
}

class Tower {
    constructor(x, y) {
        const {gridX, gridY} = pixel2grid(x, y);
        this.gridX = gridX;
        this.gridY = gridY;
        const {x: x_, y: y_} = grid2pixel(gridX, gridY);
        this.x = x_ + gridPixelSizeX / 2;
        this.y = y_ + gridPixelSizeY / 2;
        this.lastShot = 0;
        this.currentEnemies = [];
    }
}

class BaseTower extends Tower {
    constructor(x, y) {
        super(x, y);
        this.cost = 10;
        this.range = 100;
        this.fireRate = 3;
        this.fireDuration = 0.1;
        this.damage = 10;
        this.maxEnemies = 1;
        this.color = "blue";
    }
}

class MultiTower extends Tower {
    constructor(x, y) {
        super(x, y);
        this.cost = 20;
        this.range = 150;
        this.fireRate = 2;
        this.fireDuration = 0.1;
        this.damage = 8;
        this.maxEnemies = 5;
        this.color = "green";
    }
}


const availableTowers = [BaseTower, MultiTower];


class PathMatrix {
    constructor(gridSizeX, gridSizeY, startX, startY, endX, endY) {
        this.gridSizeX = gridSizeX;
        this.gridSizeY = gridSizeY;
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
        this.matrix = new Array(gridSizeX * gridSizeY * 2).fill(NaN);
    }

    set(x, y, nextX, nextY) {
        this.matrix[(x + y * this.gridSizeX) * 2 + 0] = nextX;
        this.matrix[(x + y * this.gridSizeX) * 2 + 1] = nextY;
    }

    get(x, y) {
        return {
            x: this.matrix[(x + y * this.gridSizeX) * 2 + 0],
            y: this.matrix[(x + y * this.gridSizeX) * 2 + 1],
        };
    }

    updatePaths() {
        // clear matrix
        this.matrix.fill(NaN);
        this.set(this.endX, this.endY, this.endX+1, this.endY+1);

        // put towers on grid
        towers.forEach(tower => {
            const {gridX, gridY} = tower;
            this.set(gridX, gridY, -1, -1);
        });

        // update path matrix
        const queue = [{x: this.endX, y: this.endY, dist: 0}];
        while (queue.length > 0) {
            const {x, y, dist} = queue.shift();
            for (let i = x-1; i <= x+1; i++) {
                for (let j = y-1; j <= y+1; j++) {
                    const newdist = dist + Math.hypot(i - x, j - y);
                    // self
                    if (i === x && j === y) {
                        continue;
                    }
                    // out of bounds
                    if (i < 0 || i >= this.gridSizeX || j < 0 || j >= this.gridSizeY) {
                        continue;
                    }
                    // tower or already visited
                    if (!isNaN(this.get(i, j).x)) {
                        continue;
                    }
                    

                    // insert into queue
                    let inserted = false;
                    for (let k = 0; k < queue.length; k++) {
                        if (queue[k].dist > newdist) {
                            queue.splice(k, 0, {x: i, y: j, dist: newdist});
                            inserted = true;
                            break;
                        }
                    }
                    if (!inserted) {
                        queue.push({x: i, y: j, dist: newdist});
                    }

                    // update path matrix
                    this.set(i, j, x, y);
                }
            }
        }

    }
}

const matrix = new PathMatrix(gridSizeX, gridSizeY, 0, 0, gridSizeX-1, gridSizeY-1);
matrix.updatePaths();


// Function to place a tower
function placeTower(x, y) {
    tower = new availableTowers[currentSlectedTower](x, y);
    if (money < tower.cost) return;
    if (towers.some(t => t.x === tower.x && t.y === tower.y)) return;
    money -= tower.cost;
    towers.push(tower);
    matrix.updatePaths();
}

function drawGrid() {
    ctx.strokeStyle = `rgba(0, 0, 0, 0.1)`;
    for (let i = 0; i <= gridSizeX; i++) {
        const {x, y} = grid2pixel(i, 0);
        ctx.beginPath();
        ctx.moveTo(x, gridStartPixelY);
        ctx.lineTo(x, gridEndPixelY);
        ctx.stroke();
    }
    for (let i = 0; i <= gridSizeY; i++) {
        const {x, y} = grid2pixel(0, i);
        ctx.beginPath();
        ctx.moveTo(gridStartPixelX, y);
        ctx.lineTo(gridEndPixelX, y);
        ctx.stroke();
    }
}


// Function to draw towers
function drawTowers() {
    towers.forEach(tower => {
        ctx.fillStyle = tower.color;
        ctx.fillRect(tower.x - gridPixelSizeX/2, tower.y - gridPixelSizeY/2, gridPixelSizeX, gridPixelSizeY);
    });
}

// Function to spawn monsters
function spawnMonster(time) {
    if (time - lastSpawn > spawnInterval) {
        monsters.push({
            x: monsterPath.start.x,
            y: monsterPath.start.y,
            speed: .1 + Math.random() * .1,
            maxHealth: 100,
            health: 100,
            reward: 2,
        });
        lastSpawn = time;
    }
}

// Function to draw monsters
function drawMonsters() {
    monsters.forEach(monster => {
        ctx.beginPath();
        const h = monster.health / monster.maxHealth;
        ctx.fillStyle = `rgb(${(1-h)*200}, ${(1-h)*200}, ${(1-h)*200})`;
        ctx.arc(monster.x, monster.y, 8, 0, 2 * Math.PI);
        ctx.fill();
    });
}

// Function to move monsters
function moveMonsters(deltaTime) {
    monsters.forEach(monster => {
        const {gridX, gridY} = pixel2grid(monster.x, monster.y);
        const {x: destGridX, y: destGridY} = matrix.get(gridX, gridY);
        const {x: destX, y: destY} = grid2pixel(destGridX, destGridY);
        const destDist = Math.hypot(destX - monster.x, destY - monster.y);
        monster.x += monster.speed * deltaTime * (destX - monster.x) / destDist;
        monster.y += monster.speed * deltaTime * (destY - monster.y) / destDist;
        // TODO: this might fail if speed or deltaTime is too high
    });
}

function drawShots() {
    towers.forEach(tower => {
        tower.currentEnemies.forEach(enemy => {
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.moveTo(tower.x, tower.y);
            ctx.lineTo(enemy.x, enemy.y);
            ctx.stroke();
        });
    });
}


function updateEnemies(time) {
    towers.forEach(tower => {
        // reset current enemies if fire duration has passed
        if (tower.lastShot + tower.fireDuration * 1000 < time) {
            tower.currentEnemies = [];
        }
        // fire shots
        if (tower.lastShot + 1000 / tower.fireRate < time) {
            tower.lastShot = time;
            // update enemies
            const enemiesInRange = monsters.filter(monster => Math.hypot(tower.x - monster.x, tower.y - monster.y) < tower.range);
            enemiesInRange.sort((a, b) => Math.hypot(tower.x - a.x, tower.y - a.y) - Math.hypot(tower.x - b.x, tower.y - b.y));
            tower.currentEnemies = enemiesInRange.slice(0, tower.maxEnemies);
            // fire shots
            tower.currentEnemies.forEach(enemy => {
                enemy.health -= tower.damage;
                if (enemy.health <= 0) {
                    monsters.splice(monsters.indexOf(enemy), 1);
                    money += enemy.reward;
                    monsterKilled++;
                    spawnInterval *= 0.99;
                }
            });
        }
    });
}


function monsterInGoal() {
    monsters.forEach(monster => {
        if (monster.x > monsterPath.end.x && monster.y > monsterPath.end.y) {
            monsters.splice(monsters.indexOf(monster), 1);
            lifes--;
        }
    });
}


// draw directions where monsters go for debugging
function drawDirections() {
    for (let i = 0; i < gridSizeX; i++) {
        for (let j = 0; j < gridSizeY; j++) {
            const {x, y} = grid2pixel(i, j);
            const {x: nextX, y: nextY} = matrix.get(i, j);
            if (!isNaN(nextX) && nextX >= 0) {
                ctx.strokeStyle = "red";
                ctx.beginPath();
                ctx.moveTo(x, y);
                const {x: nextX_, y: nextY_} = grid2pixel(nextX, nextY);
                ctx.lineTo((nextX_+x)/2, (nextY_+y)/2);
                ctx.stroke();
            }
        }
    }

}


function drawStatus() {

    // draw status
    ctx.fillStyle = "black";
    ctx.font = "20px Arial";
    ctx.fillText("Lifes: " + lifes, 10, 30);
    ctx.fillText("Money: " + money, 10, 60);
    ctx.fillText("Killed: " + monsterKilled, 250, 30);

    // draw available towers
    ctx.fillText("Available towers: ", 10, 90);
    for (let i = 0; i < availableTowers.length; i++) {
        const sampleTower = new availableTowers[i](0, 0);
        ctx.fillStyle = sampleTower.color;
        ctx.fillRect(10 + i * 60, 100, 20, 20);
        ctx.fillStyle = "black";
        ctx.fillText(sampleTower.cost, 35 + i * 60, 117);
        if (currentSlectedTower === i) {
            ctx.strokeStyle = "black";
            ctx.strokeRect(9 + i * 60, 99, 23, 23);
        }
    }
    // draw status outline
    ctx.strokeStyle = "black";
    ctx.strokeRect(0, 0, 800, 150);
}

// Game loop
function gameLoop(time) {
    const deltaTime = time - lastTime;
    lastTime = time;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    spawnMonster(time);
    moveMonsters(deltaTime);
    drawMonsters();
    drawTowers();
    updateEnemies(time);
    drawShots();
    monsterInGoal();
    drawStatus();
    // drawDirections();

    requestAnimationFrame(gameLoop);
}

canvas.addEventListener('click', function(event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    if (x < 800 && y < 150) {
        availableTowers.forEach((tower, index) => {
            if (x > 10 + index * 60 && x < 30 + index * 60 && y > 100 && y < 120) {
                currentSlectedTower = index;
            }
        });
    } else {
        placeTower(x, y);
    }
});

requestAnimationFrame(gameLoop);
    </script>
</html>
